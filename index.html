<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Lectura Rápida</title>
    <!-- Se usan enlaces absolutos para las bibliotecas de JavaScript para garantizar que funcionen en cualquier entorno de alojamiento web, como GitHub Pages. -->
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.16.105/pdf.min.js"></script>
    <script src='https://cdn.jsdelivr.net/npm/tesseract.js@5/dist/tesseract.min.js'></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;600&family=Playfair+Display:wght@400;600&family=Fira+Code:wght@400;600&display=swap');
        
        /* CSS custom properties for dynamic colors */
        :root {
            --highlight-color: #fde68a; /* Default highlight color */
            --text-color: #1f2937; /* Default text color (gray-800) */
            --bg-color: #f3f4f6;
            --border-color: #e5e7eb;
            --input-bg-color: #ffffff;
            --input-text-color: #333333;
        }
        
        /* Theme classes */
        body {
            font-family: 'Inter', sans-serif;
            transition: background-color 0.3s, color 0.3s;
            color: var(--text-color); /* The main body text color is now separate from the reading area color */
        }
        .light {
            --bg-color: #f3f4f6;
            --text-color: #1f2937;
            --border-color: #e5e7eb;
            --input-bg-color: #ffffff;
            --input-text-color: #333333;
        }
        .dark {
            --bg-color: #1f2937;
            --highlight-color: #a16207; /* Darker highlight for dark mode */
            --text-color: #e5e7eb;
            --border-color: #374151;
            --input-bg-color: #374151;
            --input-text-color: #e5e7eb;
        }
        .sepia {
            --bg-color: #fbf0d9;
            --highlight-color: #c9b48c;
            --text-color: #5b4636;
            --border-color: #e0d4bc;
            --input-bg-color: #f2eadc;
            --input-text-color: #5b4636;
        }
        
        /* Font classes */
        .font-inter { font-family: 'Inter', sans-serif; }
        .font-serif { font-family: 'Playfair Display', serif; }
        .font-mono { font-family: 'Fira Code', monospace; }

        /* General UI improvements using CSS variables */
        .bg-card { background-color: var(--input-bg-color); }
        .border-theme { border-color: var(--border-color); }
        .text-theme { color: var(--text-color); }
        #text-input, select, .p-8 { background-color: var(--input-bg-color); color: var(--input-text-color); border-color: var(--border-color); }

        /* Reading area specific styles */
        #reading-area {
            position: relative;
        }
        #reading-area .word {
            transition: all 0.2s ease-in-out;
            border-radius: 0.25rem;
            padding: 0 0.1rem;
            cursor: pointer;
        }

        /* Styles for different highlight modes */
        #reading-area.highlight-background .word.highlighted {
            background-color: var(--highlight-color);
            padding: 0 0.2rem;
        }
        #reading-area.highlight-underline .word.highlighted {
            text-decoration: underline;
            text-decoration-color: var(--highlight-color);
            text-underline-offset: 4px;
        }
        #reading-area.highlight-bold-orp .word.highlighted {
            font-weight: bold;
        }
        #reading-area.highlight-bold-orp .word b {
            font-weight: 800;
            text-decoration: underline;
            text-underline-offset: 4px;
            text-decoration-color: var(--highlight-color);
        }

        /* Single word mode styles */
        #reading-area.single-word-mode {
            display: flex;
            justify-content: center;
            align-items: center;
            text-align: center;
            font-weight: bold;
            font-size: 3rem;
            height: 10rem;
            white-space: nowrap;
            overflow: hidden;
        }

        .single-word-display {
            font-weight: 800;
        }
        
        .gaze-marker {
            position: absolute;
            top: 0;
            left: 50%;
            width: 2px;
            height: 100%;
            background-color: #ef4444; /* red-500 */
            z-index: 10;
            transform: translateX(-50%);
            pointer-events: none; /* Ignore mouse events */
        }
        
        /* General layout adjustments for smaller screens */
        body {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start;
            min-height: 100vh;
            padding: 1rem;
            box-sizing: border-box;
            font-size: 1rem; /* Increased base font size */
        }

        .bg-card {
            height: auto;
            max-width: 100%;
            overflow-y: auto;
        }

        #status-message-box {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            padding: 10px 20px;
            border-radius: 8px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            opacity: 0;
            transition: opacity 0.5s ease-in-out;
            z-index: 1000;
        }

        .status-show {
            opacity: 1;
        }
        
        /* Responsive adjustments for controls */
        @media (max-width: 640px) {
            body {
                padding: 0.5rem;
                font-size: 0.875rem; /* Slightly smaller on very small screens */
            }
            .p-4 { padding: 0.5rem; }
            .md\:p-8 { padding: 1rem; }
            .text-xl { font-size: 1.25rem; }
            .text-3xl { font-size: 1.75rem; }
            .text-sm { font-size: 0.875rem; }
            .text-xs { font-size: 0.75rem; }
            .py-2 { padding-top: 0.25rem; padding-bottom: 0.25rem; }
            .py-3 { padding-top: 0.5rem; padding-bottom: 0.5rem; }
            .px-4 { padding-left: 0.5rem; padding-right: 0.5rem; }
            .px-6 { padding-left: 1rem; padding-right: 1rem; }
            .h-20 { height: 6rem; }

            .grid-cols-3 {
                grid-template-columns: repeat(2, 1fr);
            }
             .gap-4 { gap: 0.5rem; }
            .md\:w-1\/3 {
                width: 100%;
            }
        }
    </style>
</head>
<body class="light flex flex-col items-center justify-center min-h-screen p-4" style="background-color: var(--bg-color);">

    <!-- Status Message Box -->
    <div id="status-message-box" class="bg-blue-500 text-white font-semibold"></div>

    <div class="bg-card rounded-2xl shadow-xl p-4 md:p-8 max-w-4xl w-full border border-theme">
        <div class="flex flex-col md:flex-row items-center justify-between mb-4">
            <h1 class="text-xl md:text-3xl font-bold mb-2 md:mb-0">Lectura Rápida</h1>
            <div class="flex items-center gap-2 md:gap-4">
                <button id="save-button" class="bg-blue-500 text-white font-semibold py-2 px-3 rounded-xl hover:bg-blue-600 focus:outline-none focus:ring-2 focus:ring-blue-500 transition duration-200 shadow-md text-xs md:text-sm">
                    Guardar Sesión
                </button>
                <button id="load-button" class="bg-gray-500 text-white font-semibold py-2 px-3 rounded-xl hover:bg-gray-600 focus:outline-none focus:ring-2 focus:ring-gray-500 transition duration-200 shadow-md text-xs md:text-sm">
                    Cargar Sesión
                </button>
            </div>
        </div>
        
        <!-- Progress Bar -->
        <div class="w-full bg-gray-200 rounded-full h-1.5 mb-2">
            <div id="progress-bar" class="bg-blue-600 h-1.5 rounded-full transition-all duration-300 ease-in-out" style="width: 0%;"></div>
        </div>
        
        <!-- Main Application Container -->
        <div class="flex flex-col items-center w-full">
            
            <!-- Text Input and File Upload -->
            <div id="text-input-section" class="flex flex-col md:flex-row w-full gap-2 mb-2">
                <textarea id="text-input" class="flex-1 h-20 md:h-28 p-2 border rounded-xl focus:outline-none focus:ring-2 focus:ring-blue-500 transition duration-200" placeholder="Pega aquí el texto o haz clic en 'Cargar Archivo' para un .txt o .pdf."></textarea>
                <div class="flex flex-col gap-2 w-full md:w-auto">
                    <label id="file-input-label-text" for="file-input-text" class="bg-indigo-500 text-white font-semibold py-2 px-3 rounded-xl hover:bg-indigo-600 focus:outline-none focus:ring-2 focus:ring-indigo-500 transition duration-200 shadow-md cursor-pointer text-center whitespace-nowrap text-xs md:text-sm">
                        Cargar Archivo
                    </label>
                    <input type="file" id="file-input-text" accept=".txt, .pdf" class="hidden">
                    <label id="file-input-label-image" for="file-input-image" class="bg-indigo-500 text-white font-semibold py-2 px-3 rounded-xl hover:bg-indigo-600 focus:outline-none focus:ring-2 focus:ring-indigo-500 transition duration-200 shadow-md cursor-pointer text-center whitespace-nowrap text-xs md:text-sm">
                        Extraer texto de Imagen
                    </label>
                    <input type="file" id="file-input-image" accept=".jpg, .jpeg, .png, .webp" class="hidden">
                </div>
            </div>

            <!-- Practice Mode Button -->
            <div class="w-full mb-2">
                 <button id="practice-button" class="bg-purple-500 text-white font-semibold py-2 px-3 rounded-xl hover:bg-purple-600 focus:outline-none focus:ring-2 focus:ring-purple-500 transition duration-200 shadow-md w-full text-xs md:text-sm">
                    Modo Práctica
                </button>
            </div>
            
            <!-- Critical Reading Prompts Section -->
            <div id="critical-reading-questions-container" class="w-full mb-2 p-3 rounded-xl border border-theme" style="display: none;">
                <!-- New: separate sections for multiple choice and free-form questions -->
                <div id="multiple-choice-section" class="mb-4">
                    <h3 class="font-bold text-sm md:text-lg mb-1">Preguntas de Comprensión (Opción Múltiple)</h3>
                    <div id="multiple-choice-questions" class="text-sm space-y-2">
                        <!-- Multiple choice questions will be inserted here -->
                    </div>
                </div>
                
                <div id="critical-reading-section">
                    <h3 class="font-bold text-sm md:text-lg mb-1">Preguntas de Lectura Crítica</h3>
                    <div id="critical-reading-questions" class="text-sm space-y-2">
                        <!-- Critical reading questions will be inserted here -->
                    </div>
                </div>
                <div id="loading-questions" class="hidden text-center text-gray-500 italic text-sm">
                    Generando preguntas...
                </div>
            </div>
            <div class="w-full mb-2">
                 <button id="generate-questions-button" class="bg-teal-500 text-white font-semibold py-2 px-3 rounded-xl hover:bg-teal-600 focus:outline-none focus:ring-2 focus:ring-teal-500 transition duration-200 shadow-md w-full text-xs md:text-sm">
                    Generar Preguntas
                </button>
            </div>
            

            <!-- Reading Display Area -->
            <div id="reading-display-container" class="relative w-full mb-2">
                <div id="reading-area" class="bg-card w-full h-24 md:h-40 p-2 md:p-4 border rounded-xl overflow-y-auto focus:outline-none border-theme">
                    <span id="reading-intro" class="text-center italic text-gray-600">El texto de tu lectura aparecerá aquí.</span>
                </div>
            </div>
            
            <!-- Word Counter and Stats -->
            <div class="w-full flex flex-col md:flex-row justify-between mb-2 text-xs md:text-sm text-gray-600">
                <div id="word-counter" class="mb-1 md:mb-0"></div>
                <div id="stats-display" class="mb-1 md:mb-0 text-right"></div>
            </div>

            <!-- Application Controls -->
            <div id="main-controls-container" class="w-full grid grid-cols-3 gap-2 mb-2">
                <button id="back-button" class="bg-gray-400 text-white font-semibold py-2 px-3 rounded-xl hover:bg-gray-500 focus:outline-none focus:ring-2 focus:ring-gray-400 transition duration-200 shadow-md flex items-center justify-center text-xs md:text-sm">
                    <svg class="w-4 h-4 mr-1" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 19l-7-7 7-7"></path></svg>
                    Atrás
                </button>
                <button id="start-button" class="bg-green-500 text-white font-semibold py-2 px-3 rounded-xl hover:bg-green-600 focus:outline-none focus:ring-2 focus:ring-green-500 transition duration-200 shadow-md flex items-center justify-center text-xs md:text-sm">
                    <svg class="w-4 h-4 mr-1" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M14.752 11.189l-3.296 2.083a1 1 0 01-1.455-.788V9.124a1 1 0 011.455-.788l3.296 2.083a1 1 0 010 1.57z"></path><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg>
                    Iniciar
                </button>
                <button id="pause-button" class="bg-yellow-500 text-white font-semibold py-2 px-3 rounded-xl hover:bg-yellow-600 focus:outline-none focus:ring-2 focus:ring-yellow-500 transition duration-200 shadow-md flex items-center justify-center text-xs md:text-sm">
                    <svg class="w-4 h-4 mr-1" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 9v6m4-6v6m4-3a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg>
                    Pausar
                </button>
                <button id="stop-button" class="bg-red-500 text-white font-semibold py-2 px-3 rounded-xl hover:bg-red-600 focus:outline-none focus:ring-2 focus:ring-red-500 transition duration-200 shadow-md flex items-center justify-center text-xs md:text-sm">
                    <svg class="w-4 h-4 mr-1" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 14l2-2m0 0l2-2m-2 2l-2-2m2 2l2 2m7-2a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg>
                    Parar
                </button>
                <button id="next-button" class="bg-gray-400 text-white font-semibold py-2 px-3 rounded-xl hover:bg-gray-500 focus:outline-none focus:ring-2 focus:ring-gray-400 transition duration-200 shadow-md flex items-center justify-center text-xs md:text-sm">
                    <svg class="w-4 h-4 mr-1" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7"></path></svg>
                    Adelante
                </button>
                 <button id="clear-button" class="bg-red-700 text-white font-semibold py-2 px-3 rounded-xl hover:bg-red-800 focus:outline-none focus:ring-2 focus:ring-red-700 transition duration-200 shadow-md flex items-center justify-center text-xs md:text-sm">
                    <svg class="w-4 h-4 mr-1" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.013 21H7.987a2 2 0 01-1.92-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"></path></svg>
                    Borrar
                </button>
            </div>
            
            <!-- Customization Controls Row 1 -->
            <div id="custom-controls-row-1" class="w-full flex flex-col md:flex-row items-center gap-2">
                <!-- WPM Slider -->
                <div class="flex items-center gap-1 w-full md:w-1/3">
                    <label for="wpm-slider" class="text-xs font-medium whitespace-nowrap">WPM:</label>
                    <span id="wpm-value" class="w-8 text-center font-bold">300</span>
                    <input type="range" id="wpm-slider" min="100" max="1000" value="300" step="10" class="w-full h-1.5 bg-gray-200 rounded-lg appearance-none cursor-pointer">
                </div>
                
                <!-- Theme Select -->
                <div class="flex items-center gap-1 w-full md:w-1/3">
                    <label for="theme-select" class="text-xs font-medium whitespace-nowrap">Tema:</label>
                    <select id="theme-select" class="w-full p-1 rounded-lg border text-xs">
                        <option value="light">Claro</option>
                        <option value="dark">Oscuro</option>
                        <option value="sepia">Sepia</option>
                    </select>
                </div>
                
                <!-- Font Select -->
                <div class="flex items-center gap-1 w-full md:w-1/3">
                    <label for="font-select" class="text-xs font-medium whitespace-nowrap">Fuente:</label>
                    <select id="font-select" class="w-full p-1 rounded-lg border text-xs">
                        <option value="inter">Inter</option>
                        <option value="serif">Serif</option>
                        <option value="mono">Mono</option>
                    </select>
                </div>
            </div>

            <!-- Customization Controls Row 2 -->
            <div id="custom-controls-row-2" class="w-full flex flex-col md:flex-row items-center gap-2 mt-2">
                <!-- Font Size Slider -->
                <div class="flex items-center gap-1 w-full md:w-1/2">
                    <label for="font-size-slider" class="text-xs font-medium whitespace-nowrap">Tamaño:</label>
                    <span id="font-size-value" class="w-8 text-center font-bold">14</span>
                    <input type="range" id="font-size-slider" min="12" max="32" value="14" step="1" class="w-full h-1.5 bg-gray-200 rounded-lg appearance-none cursor-pointer">
                </div>
                
                <!-- Mode Select -->
                <div class="flex items-center gap-1 w-full md:w-1/2">
                    <label for="mode-select" class="text-xs font-medium whitespace-nowrap">Modo:</label>
                    <select id="mode-select" class="w-full p-1 rounded-lg border text-xs">
                        <option value="highlight">Resaltado</option>
                        <option value="single-word">Una palabra a la vez</option>
                    </select>
                </div>
            </div>
            
            <!-- Customization Controls Row 3 -->
            <div id="highlight-controls" class="w-full flex flex-col md:flex-row items-center gap-2 mt-2">
                <!-- Highlight Style Select -->
                <div class="flex items-center gap-1 w-full md:w-1/2">
                    <label for="highlight-style-select" class="text-xs font-medium whitespace-nowrap">Estilo:</label>
                    <select id="highlight-style-select" class="w-full p-1 rounded-lg border text-xs">
                        <option value="highlight-background">Fondo</option>
                        <option value="highlight-underline">Subrayado</option>
                        <option value="highlight-bold-orp">Negrita (ORP)</option>
                    </select>
                </div>

                <!-- Words per Chunk Slider -->
                <div class="flex items-center gap-1 w-full md:w-1/2">
                    <label for="words-per-chunk-slider" class="text-xs font-medium whitespace-nowrap">Grupo:</label>
                    <span id="words-per-chunk-value" class="w-8 text-center font-bold">1</span>
                    <input type="range" id="words-per-chunk-slider" min="1" max="5" value="1" step="1" class="w-full h-1.5 bg-gray-200 rounded-lg appearance-none cursor-pointer">
                </div>
            </div>

            <!-- New Control for Gaze Marker -->
            <div class="w-full flex items-center justify-center gap-1 mt-2">
                <input type="checkbox" id="gaze-marker-checkbox" class="h-3 w-3 text-blue-600 bg-gray-100 border-gray-300 rounded focus:ring-blue-500">
                <label for="gaze-marker-checkbox" class="text-xs font-medium">Usar Marcador de Gaze</label>
            </div>
            
            <!-- Highlight and Font Color Pickers -->
            <div class="w-full flex flex-col md:flex-row items-center justify-center gap-4 mt-2">
                <div class="flex items-center gap-1">
                    <label for="highlight-color-picker" class="text-xs font-medium whitespace-nowrap">Color Resalte:</label>
                    <input type="color" id="highlight-color-picker" value="#fde68a" class="w-12 h-8 rounded-lg border border-gray-300 cursor-pointer">
                </div>
                <!-- NEW: Font Color Picker -->
                <div class="flex items-center gap-1">
                    <label for="font-color-picker" class="text-xs font-medium whitespace-nowrap">Color Fuente:</label>
                    <input type="color" id="font-color-picker" value="#1f2937" class="w-12 h-8 rounded-lg border border-gray-300 cursor-pointer">
                </div>
            </div>

            <div class="mt-4 text-xs text-center text-gray-500">
                <p>Creador: Juan Miguel Ríos Redondo</p>
            </div>

        </div>
    </div>

    <script>
        // Se usa un enlace absoluto para el worker de PDF.js para evitar errores de carga en GitHub Pages
        pdfjsLib.GlobalWorkerOptions.workerSrc = `https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.16.105/pdf.worker.min.js`;

        // ========================
        // DOM Element References
        // ========================
        const textInput = document.getElementById('text-input');
        const readingArea = document.getElementById('reading-area');
        const startButton = document.getElementById('start-button');
        const pauseButton = document.getElementById('pause-button');
        const stopButton = document.getElementById('stop-button');
        const wpmSlider = document.getElementById('wpm-slider');
        const wpmValueSpan = document.getElementById('wpm-value');
        const progressBar = document.getElementById('progress-bar');
        const themeSelect = document.getElementById('theme-select');
        const fontSelect = document.getElementById('font-select');
        const fontSizeSlider = document.getElementById('font-size-slider');
        const fontSizeValueSpan = document.getElementById('font-size-value');
        const saveButton = document.getElementById('save-button');
        const loadButton = document.getElementById('load-button');
        const wordCounter = document.getElementById('word-counter');
        const statsDisplay = document.getElementById('stats-display');
        const fileInputText = document.getElementById('file-input-text');
        const fileInputImage = document.getElementById('file-input-image');
        const practiceButton = document.getElementById('practice-button');
        const modeSelect = document.getElementById('mode-select');
        const statusMessageBox = document.getElementById('status-message-box');
        const highlightColorPicker = document.getElementById('highlight-color-picker');
        
        // New DOM references for highlight improvements
        const highlightStyleSelect = document.getElementById('highlight-style-select');
        const wordsPerChunkSlider = document.getElementById('words-per-chunk-slider');
        const wordsPerChunkValueSpan = document.getElementById('words-per-chunk-value');
        const highlightControls = document.getElementById('highlight-controls');
        const gazeMarkerCheckbox = document.getElementById('gaze-marker-checkbox');

        // New DOM references for critical reading questions
        const generateQuestionsButton = document.getElementById('generate-questions-button');
        const criticalReadingQuestionsContainer = document.getElementById('critical-reading-questions-container');
        // New DOM references for the updated question sections
        const multipleChoiceQuestions = document.getElementById('multiple-choice-questions');
        const criticalReadingQuestions = document.getElementById('critical-reading-questions');
        const loadingQuestions = document.getElementById('loading-questions');

        // New DOM references for navigation buttons
        const backButton = document.getElementById('back-button');
        const nextButton = document.getElementById('next-button');

        // New DOM reference for clear button
        const clearButton = document.getElementById('clear-button');

        // NEW: DOM reference for font color picker
        const fontColorPicker = document.getElementById('font-color-picker');

        // ========================
        // State Variables
        // ========================
        let words = [];
        let currentIndex = 0;
        let timer = null;
        let isPaused = false;
        let isReading = false;
        let startTime = 0;
        const punctuationPauseMultiplier = {
            ',': 0.5,
            ';': 0.7,
            ':': 0.7,
            '.': 1.0,
            '?': 1.0,
            '!': 1.0
        };

        // ========================
        // Helper Functions for ORP
        // ========================

        // Determines the number of letters to bold for Optimal Recognition Points (ORP)
        const getOrpLength = (word) => {
            const cleanWord = word.replace(/[.,?!;:]/g, '');
            if (cleanWord.length <= 2) return cleanWord.length;
            if (cleanWord.length <= 5) return 2;
            return 3;
        };

        // Applies ORP formatting to a word
        const getOrpWord = (word) => {
            const orpLength = getOrpLength(word);
            const firstPart = word.substring(0, orpLength);
            const restOfWord = word.substring(orpLength);
            return `<b>${firstPart}</b>${restOfWord}`;
        };

        // ========================
        // Core Functions
        // ========================

        // Displays a temporary status message
        const showStatusMessage = (message, isError = false) => {
            statusMessageBox.textContent = message;
            statusMessageBox.classList.add('status-show');
            if (isError) {
                statusMessageBox.classList.remove('bg-blue-500');
                statusMessageBox.classList.add('bg-red-500');
            } else {
                statusMessageBox.classList.remove('bg-red-500');
                statusMessageBox.classList.add('bg-blue-500');
            }
            setTimeout(() => {
                statusMessageBox.classList.remove('status-show');
            }, 3000);
        };

        // Saves the current reading session to local storage
        const saveSession = () => {
            if (words.length === 0) {
                showStatusMessage('No hay texto para guardar.', true);
                return;
            }
            try {
                const sessionData = {
                    text: textInput.value,
                    progress: currentIndex,
                    theme: themeSelect.value,
                    font: fontSelect.value,
                    fontSize: fontSizeSlider.value,
                    mode: modeSelect.value,
                    highlightStyle: highlightStyleSelect.value,
                    highlightColor: highlightColorPicker.value,
                    fontColor: fontColorPicker.value,
                    wordsPerChunk: wordsPerChunkSlider.value,
                    timestamp: new Date().toISOString()
                };
                localStorage.setItem('speedReadingSession', JSON.stringify(sessionData));
                showStatusMessage('Sesión guardada exitosamente.');
            } catch (error) {
                console.error("Error saving session to localStorage:", error);
                showStatusMessage('Error al guardar la sesión.', true);
            }
        };

        // Loads a saved session from local storage
        const loadSession = () => {
            try {
                const storedSession = localStorage.getItem('speedReadingSession');
                if (storedSession) {
                    const data = JSON.parse(storedSession);
                    textInput.value = data.text;
                    currentIndex = data.progress;
                    
                    // Update UI based on loaded data
                    themeSelect.value = data.theme || 'light';
                    fontSelect.value = data.font || 'inter';
                    fontSizeSlider.value = data.fontSize || '14';
                    modeSelect.value = data.mode || 'highlight';
                    highlightStyleSelect.value = data.highlightStyle || 'highlight-background';
                    highlightColorPicker.value = data.highlightColor || '#fde68a';
                    // Load and apply font color
                    fontColorPicker.value = data.fontColor || '#1f2937';
                    readingArea.style.color = fontColorPicker.value;

                    wordsPerChunkSlider.value = data.wordsPerChunk || '1';
                    wpmSlider.value = data.wpm || '300';
                    wpmValueSpan.textContent = wpmSlider.value;
                    wordsPerChunkValueSpan.textContent = data.wordsPerChunk || '1';
                    fontSizeValueSpan.textContent = data.fontSize || '14';

                    // Manually trigger change events to apply styling and mode
                    const themeChangeEvent = new Event('change');
                    themeSelect.dispatchEvent(themeChangeEvent);

                    const fontChangeEvent = new Event('change');
                    fontSelect.dispatchEvent(fontChangeEvent);

                    const modeChangeEvent = new Event('change');
                    modeSelect.dispatchEvent(modeChangeEvent);
                    
                    const highlightStyleChangeEvent = new Event('change');
                    highlightStyleSelect.dispatchEvent(highlightStyleChangeEvent);

                    const highlightColorChangeEvent = new Event('input');
                    highlightColorPicker.dispatchEvent(highlightColorChangeEvent);
                    
                    readingArea.style.fontSize = `${data.fontSize || '14'}px`;
                    
                    updateReadingDisplay(textInput.value);
                    updateWordCounter();
                    updateProgressBar();
                    showStatusMessage('Sesión cargada desde el dispositivo.');
                } else {
                    showStatusMessage('No se encontró una sesión guardada.', false);
                }
            } catch (error) {
                console.error("Error loading session from localStorage:", error);
                showStatusMessage('Error al cargar la sesión.', true);
            }
        };

        // Loads text from a local file (.txt or .pdf)
        const loadFile = (file) => {
            const reader = new FileReader();
            
            reader.onloadstart = () => {
                showStatusMessage("Cargando archivo...");
                textInput.value = '';
                stopReading();
            };
            
            reader.onerror = () => {
                showStatusMessage("Error al leer el archivo.", true);
            };
            
            if (file.type === 'text/plain') {
                reader.onload = (event) => {
                    textInput.value = event.target.result;
                    showStatusMessage("Archivo de texto cargado exitosamente.");
                    updateReadingDisplay(textInput.value);
                };
                reader.readAsText(file);
            } else if (file.type === 'application/pdf') {
                reader.onload = async (e) => {
                    try {
                        const arrayBuffer = e.target.result;
                        const pdf = await pdfjsLib.getDocument({ data: arrayBuffer }).promise;
                        let fullText = '';
                        
                        for (let i = 1; i <= pdf.numPages; i++) {
                            const page = await pdf.getPage(i);
                            const textContent = await page.getTextContent();
                            const pageText = textContent.items.map(item => item.str).join(' ').replace(/-\s*/g, '');
                            fullText += pageText + ' ';
                        }
                        textInput.value = fullText.trim();
                        showStatusMessage("PDF cargado exitosamente.");
                        updateReadingDisplay(textInput.value);
                    } catch (error) {
                        showStatusMessage("Error al procesar el PDF.", true);
                        console.error('Error al procesar el PDF:', error);
                    }
                };
                reader.readAsArrayBuffer(file);
            } else {
                showStatusMessage("Formato de archivo no soportado.", true);
            }
        };

        /**
         * @description Extracts text from an image using the Tesseract.js library.
         * The function performs OCR directly in the browser, eliminating the need for an external API call.
         * @param {File} file The image file to process.
         */
        const extractTextFromImage = async (file) => {
            showStatusMessage('Procesando imagen, esto puede tardar unos segundos...');
            try {
                const { data: { text } } = await Tesseract.recognize(
                    file,
                    'spa', // Set language to Spanish
                    { logger: m => console.log(m) } // Log progress
                );
                
                if (text && text.trim().length > 0) {
                    textInput.value = text.trim();
                    updateReadingDisplay(textInput.value);
                    showStatusMessage('Texto extraído exitosamente.');
                } else {
                    showStatusMessage("No se pudo extraer el texto de la imagen. Intenta con una imagen más clara.", true);
                }
            } catch (error) {
                console.error('Error durante el reconocimiento de OCR:', error);
                showStatusMessage('Error al procesar la imagen.', true);
            }
        };
        
        /**
         * @description Generates reading comprehension and critical thinking questions using the Gemini API.
         * The function now generates multiple-choice questions for comprehension and free-form questions for critical reading.
         */
        const generateQuestions = async () => {
            const textToAnalyze = textInput.value.trim();
            if (textToAnalyze.length < 50) {
                showStatusMessage('El texto es demasiado corto para generar preguntas significativas.', true);
                return;
            }

            // Show loading state
            criticalReadingQuestionsContainer.style.display = 'block';
            loadingQuestions.classList.remove('hidden');
            multipleChoiceQuestions.innerHTML = '';
            criticalReadingQuestions.innerHTML = '';

            // This is the prompt that will instruct the model
            const prompt = `Genera preguntas de comprensión de opción múltiple y preguntas de lectura crítica abiertas sobre el siguiente texto.
            
            Preguntas de Comprensión (Opción Múltiple):
            - Genera 5 preguntas.
            - Cada pregunta debe tener 4 opciones (a, b, c, d), y una de ellas debe ser la respuesta correcta.
            
            Preguntas de Lectura Crítica:
            - Genera 5 preguntas abiertas que requieran un análisis más profundo y una respuesta personal.
            
            Formatea tu respuesta como un objeto JSON con la siguiente estructura:
            
            {
              "multiple_choice_questions": [
                {
                  "question": "Texto de la pregunta",
                  "options": [ "Opción A", "Opción B", "Opción C", "Opción D" ],
                  "correct_answer": "Respuesta correcta"
                },
                // ... más preguntas
              ],
              "critical_reading_questions": [
                "Texto de la pregunta 1",
                "Texto de la pregunta 2",
                // ... más preguntas
              ]
            }
            
            Texto:
            "${textToAnalyze}"`;

            // This is the schema for the structured JSON response
            const responseSchema = {
                type: "OBJECT",
                properties: {
                    "multiple_choice_questions": {
                        type: "ARRAY",
                        items: {
                            type: "OBJECT",
                            properties: {
                                "question": { "type": "STRING" },
                                "options": {
                                    "type": "ARRAY",
                                    "items": { "type": "STRING" }
                                },
                                "correct_answer": { "type": "STRING" }
                            },
                            "propertyOrdering": ["question", "options", "correct_answer"]
                        }
                    },
                    "critical_reading_questions": {
                        "type": "ARRAY",
                        "items": { "type": "STRING" }
                    }
                },
                "propertyOrdering": ["multiple_choice_questions", "critical_reading_questions"]
            };
            
            let chatHistory = [];
            chatHistory.push({ role: "user", parts: [{ text: prompt }] });
            const payload = { 
                contents: chatHistory,
                generationConfig: {
                    responseMimeType: "application/json",
                    responseSchema: responseSchema
                }
            };
            
            // ====================================================================================
            // INSTRUCCIONES IMPORTANTES:
            // Pega tu clave de API personal de Google AI Studio en la línea de abajo,
            // dentro de las comillas dobles. Esta clave es necesaria para que funcione
            // la generación de preguntas.
            // ====================================================================================
            const apiKey = "";

            const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-05-20:generateContent?key=${apiKey}`;

            // Exponential backoff for API calls
            const maxRetries = 3;
            let currentRetry = 0;
            const fetchWithRetry = async () => {
                try {
                    const response = await fetch(apiUrl, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(payload)
                    });

                    if (!response.ok) {
                        if (response.status === 429 && currentRetry < maxRetries) {
                            const delay = Math.pow(2, currentRetry) * 1000;
                            currentRetry++;
                            await new Promise(resolve => setTimeout(resolve, delay));
                            return fetchWithRetry();
                        } else {
                            throw new Error(`Error HTTP: ${response.status}`);
                        }
                    }

                    const result = await response.json();
                    
                    if (result.candidates && result.candidates.length > 0 &&
                        result.candidates[0].content && result.candidates[0].content.parts &&
                        result.candidates[0].content.parts.length > 0) {
                        
                        const jsonText = result.candidates[0].content.parts[0].text;
                        const data = JSON.parse(jsonText);
                        
                        // Render Multiple Choice Questions
                        const mcqHtml = data.multiple_choice_questions.map((q, index) => `
                            <div class="mb-4">
                                <p class="font-semibold text-sm mb-1">${index + 1}. ${q.question}</p>
                                <ul class="list-none space-y-1 ml-4 text-xs">
                                    ${q.options.map(option => `
                                        <li><label><input type="radio" name="mcq-${index}" class="mr-2">${option}</label></li>
                                    `).join('')}
                                </ul>
                            </div>
                        `).join('');
                        multipleChoiceQuestions.innerHTML = mcqHtml;
                        
                        // Render Critical Reading Questions
                        const crqHtml = data.critical_reading_questions.map((q, index) => `
                            <li>${q}</li>
                        `).join('');
                        criticalReadingQuestions.innerHTML = `<ul class="list-disc list-inside space-y-2 text-xs">${crqHtml}</ul>`;

                        showStatusMessage('Preguntas generadas exitosamente.');
                    } else {
                        throw new Error('Respuesta de la API inesperada.');
                    }
                } catch (error) {
                    console.error('Error al generar preguntas:', error);
                    multipleChoiceQuestions.innerHTML = `<p class="text-red-500">Error al generar preguntas de opción múltiple.</p>`;
                    criticalReadingQuestions.innerHTML = `<p class="text-red-500">Error al generar preguntas de lectura crítica.</p>`;
                    showStatusMessage('Error al generar preguntas.', true);
                } finally {
                    loadingQuestions.classList.add('hidden');
                }
            };
            
            fetchWithRetry();
        };

        // Updates the reading area based on the selected mode
        const updateReadingDisplay = (text) => {
            words = text.split(/\s+/).filter(word => word.length > 0);
            const mode = modeSelect.value;
            const highlightStyle = highlightStyleSelect.value;

            // Clear previous styles and content
            readingArea.innerHTML = '';
            // Se limpian las clases de modo
            readingArea.classList.remove('highlight-background', 'highlight-underline', 'highlight-bold-orp', 'single-word-mode');
            
            if (words.length > 0) {
                if (mode === 'highlight') {
                    // Set white-space to preserve formatting in highlight mode
                    readingArea.style.whiteSpace = 'pre-wrap';
                    
                    readingArea.classList.add(highlightStyle);
                    words.forEach((word, index) => {
                        const span = document.createElement('span');
                        span.className = 'word cursor-pointer';
                        span.dataset.index = index;
                        // Comentario: ORP (Optimal Recognition Point) es el punto óptimo donde el ojo se fija en una palabra.
                        // El estilo `highlight-bold-orp` resalta este punto con negrita y un subrayado.
                        // El color del subrayado es el color de resalte, mientras que el color de la fuente
                        // es el color del tema seleccionado.
                        if (highlightStyle === 'highlight-bold-orp') {
                            span.innerHTML = getOrpWord(word) + ' ';
                        } else {
                            span.textContent = word + ' ';
                        }
                        readingArea.appendChild(span);
                    });
                } else if (mode === 'single-word') {
                    // Reset white-space for single-word mode
                    readingArea.style.whiteSpace = 'nowrap';
                    
                    readingArea.classList.add('single-word-mode');
                }
                readingArea.classList.remove('italic');
                readingArea.style.textAlign = mode === 'single-word' ? 'center' : 'left';
                // Initially display the word at the current index if it exists
                if (currentIndex < words.length) {
                     displayCurrentWord(currentIndex);
                }
            } else {
                readingArea.innerHTML = '<span id="reading-intro" class="text-center italic text-gray-600">El texto de tu lectura aparecerá aquí.</span>';
                readingArea.classList.add('italic');
                readingArea.style.textAlign = 'center';
            }
        };

        // Displays a single word or chunk without advancing the index or starting a timer
        const displayCurrentWord = (index) => {
            const mode = modeSelect.value;
            const wordsPerChunk = parseInt(wordsPerChunkSlider.value, 10);
            
            // Show/hide gaze marker based on checkbox state
            let gazeMarker = document.getElementById('gaze-marker');
            if (gazeMarkerCheckbox.checked && mode === 'highlight') {
                 if (!gazeMarker) {
                    gazeMarker = document.createElement('div');
                    gazeMarker.id = 'gaze-marker';
                    gazeMarker.className = 'gaze-marker';
                    readingArea.appendChild(gazeMarker);
                }
            } else {
                if (gazeMarker) {
                    gazeMarker.remove();
                }
            }


            if (mode === 'highlight') {
                const allSpans = readingArea.querySelectorAll('span.word');
                
                // Remove highlight from all words
                allSpans.forEach(span => span.classList.remove('highlighted'));

                // Highlight the new chunk
                const currentChunkEnd = Math.min(index + wordsPerChunk, words.length);
                for (let i = index; i < currentChunkEnd; i++) {
                    if (allSpans[i]) {
                         allSpans[i].classList.add('highlighted');
                    }
                }

                // Scroll to keep the chunk in view
                if (allSpans[index]) {
                    const chunkStartTop = allSpans[index].offsetTop;
                    const readingAreaHeight = readingArea.clientHeight;
                    const scrollPos = chunkStartTop - (readingAreaHeight / 2);
                    readingArea.scrollTop = scrollPos;
                }
            } else if (mode === 'single-word') {
                 readingArea.innerHTML = '';
                 
                 const currentWord = words[index];
                 if (!currentWord) return;

                 const wordSpan = document.createElement('span');
                 wordSpan.className = 'single-word-display';
                 wordSpan.textContent = currentWord;
                 
                 readingArea.appendChild(wordSpan);
            }
            updateProgressBar();
            updateWordCounter();
            updateStats();
        };

        // Renders the next word/chunk in the reading session
        const displayNextWord = () => {
            if (!isReading) return;
            
            if (currentIndex < words.length) {
                const wordsPerChunk = parseInt(wordsPerChunkSlider.value, 10);
                
                displayCurrentWord(currentIndex);
                
                const lastWordOfChunk = words[Math.min(currentIndex + wordsPerChunk - 1, words.length - 1)];
                const lastChar = lastWordOfChunk ? lastWordOfChunk.slice(-1) : '';
                const punctuationPauseMultiplier = {
                    ',': 0.5,
                    ';': 0.7,
                    ':': 0.7,
                    '.': 1.0,
                    '?': 1.0,
                    '!': 1.0
                };
                const pauseMultiplier = punctuationPauseMultiplier[lastChar] || 0;
                const baseInterval = 60000 / wpmSlider.value;
                const nextInterval = baseInterval * wordsPerChunk + (baseInterval * pauseMultiplier);
                
                currentIndex += wordsPerChunk;
                timer = setTimeout(displayNextWord, nextInterval);
            } else {
                stopReading();
                showStatusMessage("¡Lectura completada!");
            }
        };
        
        // Updates the progress bar
        const updateProgressBar = () => {
            const progress = (currentIndex / words.length) * 100;
            progressBar.style.width = `${progress}%`;
        };

        // Updates the word counter
        const updateWordCounter = () => {
            wordCounter.textContent = `Palabra ${Math.min(currentIndex, words.length)} de ${words.length}`;
        };
        
        // Updates the reading stats
        const updateStats = () => {
            if (!isReading || startTime === 0) {
                statsDisplay.textContent = '';
                return;
            }
            const elapsedTime = (Date.now() - startTime) / 1000;
            const wordsRemaining = words.length - currentIndex;
            const wpm = wpmSlider.value;
            const estimatedTime = (wordsRemaining / wpm) * 60;
            
            const formatTime = (seconds) => {
                const mins = Math.floor(seconds / 60);
                const secs = Math.floor(seconds % 60);
                return `${mins}:${secs.toString().padStart(2, '0')}`;
            };
            
            statsDisplay.textContent = `Tiempo: ${formatTime(elapsedTime)} | Restante: ~${formatTime(estimatedTime)}`;
        };
        
        // Starts the reading session
        const startReading = () => {
            // New, more robust logic to prevent word skipping
            const textToRead = textInput.value.trim();
            if (textToRead === "") {
                showStatusMessage("Por favor, pega un texto, carga un archivo o una imagen.", true);
                return;
            }

            // Re-initialize if the text has changed
            const newWords = textToRead.split(/\s+/).filter(word => word.length > 0);
            if (newWords.join(' ') !== words.join(' ')) {
                words = newWords;
                currentIndex = 0;
                updateReadingDisplay(textToRead);
            }

            if (isReading && !isPaused) {
                return; // Already reading and not paused, do nothing
            }

            // Start or resume the session
            isReading = true;
            isPaused = false;
            if (startTime === 0) {
                 startTime = Date.now();
            }
            
            // The displayNextWord function now handles the timer and the word advancement
            displayNextWord();
        };

        // Pauses the reading session
        const pauseReading = () => {
            if (timer) {
                clearTimeout(timer);
                isPaused = true;
                isReading = false;
                showStatusMessage("Pausado");
            }
        };

        // Stops the reading session and resets state
        const stopReading = () => {
            if (timer) {
                clearTimeout(timer);
            }
            isPaused = false;
            isReading = false;
            currentIndex = 0;
            startTime = 0;
            updateProgressBar();
            updateWordCounter();
            updateStats();
            updateReadingDisplay(textInput.value);
            showStatusMessage("Detenido");
            // Remove gaze marker when stopped
            let gazeMarker = document.getElementById('gaze-marker');
            if (gazeMarker) {
                gazeMarker.remove();
            }
        };

        // Clears all text and resets the application state
        const clearAll = () => {
            stopReading();
            textInput.value = '';
            words = [];
            currentIndex = 0;
            updateReadingDisplay('');
            criticalReadingQuestionsContainer.style.display = 'none';
            multipleChoiceQuestions.innerHTML = '';
            criticalReadingQuestions.innerHTML = '';
            showStatusMessage("Texto borrado.");
        };
        
        // Navigates to the previous word/chunk
        const prevWord = () => {
            const wordsPerChunk = parseInt(wordsPerChunkSlider.value, 10);
            pauseReading();
            currentIndex = Math.max(0, currentIndex - wordsPerChunk);
            displayCurrentWord(currentIndex);
        };

        // Navigates to the next word/chunk
        const nextWord = () => {
            const wordsPerChunk = parseInt(wordsPerChunkSlider.value, 10);
            pauseReading();
            currentIndex = Math.min(words.length, currentIndex + wordsPerChunk);
            displayCurrentWord(currentIndex);
        };
        
        // Loads a predefined text for practice mode
        const startPracticeMode = () => {
            const practiceText = "La práctica de la lectura de velocidad es una habilidad que mejora con la constancia y la concentración. Entrena tu mente para captar grupos de palabras en lugar de una por una, minimizando el movimiento ocular. Esto te permitirá absorber información más rápidamente y mejorar la retención. ¡Inténtalo ahora!";
            textInput.value = practiceText;
            updateReadingDisplay(practiceText);
            showStatusMessage("Modo práctica iniciado.");
        };

        // ========================
        // Event Listeners
        // ========================

        // Button clicks
        startButton.addEventListener('click', startReading);
        pauseButton.addEventListener('click', pauseReading);
        stopButton.addEventListener('click', stopReading);
        saveButton.addEventListener('click', saveSession);
        loadButton.addEventListener('click', loadSession);
        practiceButton.addEventListener('click', startPracticeMode);
        generateQuestionsButton.addEventListener('click', generateQuestions);
        
        // New navigation buttons
        backButton.addEventListener('click', prevWord);
        nextButton.addEventListener('click', nextWord);

        // New clear button
        clearButton.addEventListener('click', clearAll);

        // File inputs
        fileInputText.addEventListener('change', (event) => {
            const file = event.target.files[0];
            if (file) {
                loadFile(file);
            }
        });
        fileInputImage.addEventListener('change', (event) => {
            const file = event.target.files[0];
            if (file) {
                extractTextFromImage(file);
            }
        });

        // Sliders
        wpmSlider.addEventListener('input', () => {
            wpmValueSpan.textContent = wpmSlider.value;
        });

        fontSizeSlider.addEventListener('input', () => {
            fontSizeValueSpan.textContent = fontSizeSlider.value;
            readingArea.style.fontSize = `${fontSizeSlider.value}px`;
        });
        
        wordsPerChunkSlider.addEventListener('input', () => {
            wordsPerChunkValueSpan.textContent = wordsPerChunkSlider.value;
            updateReadingDisplay(textInput.value); // Re-render to update highlight
            displayCurrentWord(currentIndex); // Update highlight position
        });
        
        // Select boxes
        themeSelect.addEventListener('change', (e) => {
            // Apply theme CSS variables to the document
            document.body.classList.remove('light', 'dark', 'sepia');
            document.body.classList.add(e.target.value);
            
            // Re-apply the font and font-size, as switching themes might reset them
            readingArea.style.fontSize = `${fontSizeSlider.value}px`;
            document.body.classList.remove('font-inter', 'font-serif', 'font-mono');
            document.body.classList.add(`font-${fontSelect.value}`);
            
            // NEW: Update reading area font color based on mode and new theme
            if (modeSelect.value === 'single-word') {
                if (e.target.value === 'sepia') {
                    readingArea.style.color = '#1f2937'; // Negro para tema sepia
                    fontColorPicker.value = '#1f2937';
                } else {
                    readingArea.style.color = '#ef4444'; // Rojo para temas claro y oscuro
                    fontColorPicker.value = '#ef4444';
                }
            } else {
                // If not in single-word mode, reset to the user's selected color
                 readingArea.style.color = fontColorPicker.value;
            }
        });

        fontSelect.addEventListener('change', (e) => {
            document.body.classList.remove('font-inter', 'font-serif', 'font-mono');
            document.body.classList.add(`font-${e.target.value}`);
        });

        // ========================
        // Fix: The mode change now correctly handles the font color for the reading area only.
        // ========================
        modeSelect.addEventListener('change', (e) => {
            const isHighlightMode = e.target.value === 'highlight';
            highlightControls.style.display = isHighlightMode ? 'flex' : 'none';
            
            if (e.target.value === 'single-word') {
                 // NEW: Set color based on the current theme
                if (themeSelect.value === 'sepia') {
                    fontColorPicker.value = '#1f2937';
                    readingArea.style.color = '#1f2937';
                } else {
                    fontColorPicker.value = '#ef4444';
                    readingArea.style.color = '#ef4444';
                }
            } else {
                // If switching back to highlight, reset to the user's selected color
                readingArea.style.color = fontColorPicker.value;
            }

            // Trigger a full re-render to apply the correct classes and content structure
            updateReadingDisplay(textInput.value);
            // Ensure the reading area's background and border colors are updated with the current theme
            readingArea.classList.remove('bg-card');
            readingArea.classList.add('bg-card');
            readingArea.classList.remove('border-theme');
            readingArea.classList.add('border-theme');
        });

        highlightStyleSelect.addEventListener('change', () => {
            updateReadingDisplay(textInput.value);
        });

        // Highlight color picker
        highlightColorPicker.addEventListener('input', (e) => {
            document.documentElement.style.setProperty('--highlight-color', e.target.value);
        });
        
        // Font color picker listener
        fontColorPicker.addEventListener('input', (e) => {
            // Apply the user's color to the reading area
            readingArea.style.color = e.target.value;
        });

        // New: Click event listener for the reading area
        readingArea.addEventListener('click', (event) => {
            const target = event.target;
            // Check if the clicked element is a word span
            if (target.classList.contains('word') && modeSelect.value === 'highlight') {
                const newIndex = parseInt(target.dataset.index, 10);
                if (!isNaN(newIndex)) {
                    currentIndex = newIndex;
                    pauseReading();
                    displayCurrentWord(currentIndex);
                    showStatusMessage(`Posición de inicio cambiada a la palabra ${newIndex + 1}.`);
                }
            }
        });

        // Keyboard controls
        document.addEventListener('keydown', (event) => {
            if (event.code === 'Space') {
                event.preventDefault();
                isReading ? pauseReading() : startReading();
            }
            if (event.code === 'ArrowLeft') {
                event.preventDefault();
                prevWord();
            }
            if (event.code === 'ArrowRight') {
                event.preventDefault();
                nextWord();
            }
        });
        
        // Initial setup to show/hide controls based on default mode
        const isHighlightModeInitially = modeSelect.value === 'highlight';
        highlightControls.style.display = isHighlightModeInitially ? 'flex' : 'none';

        // Initial setup to update reading display if text is already present
        if (textInput.value.trim().length > 0) {
            updateReadingDisplay(textInput.value);
        }
    </script>
</body>
</html>
