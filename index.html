<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Lectura Rápida</title>
    <!-- Se usan enlaces absolutos para las bibliotecas de JavaScript para garantizar que funcionen en cualquier entorno de alojamiento web, como GitHub Pages. -->
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.16.105/pdf.min.js"></script>
    <script src='https://cdn.jsdelivr.net/npm/tesseract.js@5/dist/tesseract.min.js'></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;600&family=Playfair+Display:wght@400;600&family=Fira+Code:wght@400;600&display=swap');
        
        /* CSS custom properties for dynamic colors */
        :root {
            --highlight-color: #fde68a; /* Default highlight color */
            --text-color: #1f2937; /* Default text color (gray-800) */
            --bg-color: #f3f4f6;
            --border-color: #e5e7eb;
            --input-bg-color: #ffffff;
            --input-text-color: #333333;
        }

        /* Dark Mode */
        body.dark-mode {
            --text-color: #e5e7eb;
            --bg-color: #1f2937;
            --border-color: #4b5563;
            --input-bg-color: #374151;
            --input-text-color: #e5e7eb;
        }
        
        /* Sepia Mode */
        body.sepia-mode {
            --text-color: #4b372f;
            --bg-color: #f4ecd8;
            --border-color: #d1b8a5;
            --input-bg-color: #fef8e7;
            --input-text-color: #4b372f;
        }
        
        body {
            background-color: var(--bg-color);
            color: var(--text-color);
            transition: background-color 0.3s, color 0.3s;
        }

        .highlight-text {
            color: var(--highlight-color);
        }

        .reading-area {
            font-size: 1.5rem; /* Base font size for readability */
            line-height: 1.6;
        }

        .highlight-mode .word.highlighted {
            background-color: var(--highlight-color);
            border-radius: 0.25rem;
            padding: 0 0.1rem;
            transition: background-color 0.1s ease-in-out;
        }

        .highlight-mode .word.underline {
            text-decoration: underline;
            text-decoration-color: var(--highlight-color);
            text-decoration-thickness: 2px;
        }

        .highlight-mode .word.bold {
            font-weight: 700;
        }

        .one-word-mode {
            text-align: center;
        }

        .one-word-mode .word-display {
            font-size: 3rem;
            font-weight: 600;
            white-space: pre; /* Preserva los espacios en blanco para mantener la separación entre palabras */
            transition: color 0.1s ease-in-out;
        }
        
        /* Custom scrollbar styles */
        ::-webkit-scrollbar {
            width: 8px;
        }

        ::-webkit-scrollbar-track {
            background: #f1f1f1;
            border-radius: 10px;
        }

        ::-webkit-scrollbar-thumb {
            background: #888;
            border-radius: 10px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: #555;
        }

        .quiz-option.correct {
            background-color: #d1fae5; /* green-100 */
            border-color: #34d399; /* green-400 */
        }
        
        .quiz-option.incorrect {
            background-color: #fee2e2; /* red-100 */
            border-color: #f87171; /* red-400 */
        }

        body.dark-mode .quiz-option.correct {
            background-color: #064e3b; /* green-900 */
            border-color: #34d399; /* green-400 */
        }
        
        body.dark-mode .quiz-option.incorrect {
            background-color: #7f1d1d; /* red-900 */
            border-color: #f87171; /* red-400 */
        }
    </style>
</head>
<body class="bg-gray-100 text-gray-800 font-inter">
    <div class="container mx-auto p-4 md:p-8 flex flex-col items-center">
        <!-- Título y descripción -->
        <header class="text-center mb-6">
            <h1 class="text-4xl font-bold font-playfair mb-2">Lectura Rápida</h1>
            <p class="text-lg text-gray-600 dark:text-gray-400">Mejora tu velocidad de lectura y comprensión.</p>
        </header>

        <!-- Contenedor principal de la aplicación -->
        <div class="bg-white dark:bg-gray-700 shadow-xl rounded-2xl p-6 md:p-10 w-full max-w-5xl transition-colors duration-300">
            <!-- Barra de progreso de lectura -->
            <div id="progress-container" class="w-full h-2 bg-gray-200 dark:bg-gray-600 rounded-full mb-4">
                <div id="progress-bar" class="h-2 bg-blue-500 rounded-full transition-all duration-100 ease-linear" style="width: 0%;"></div>
            </div>

            <!-- Controles de lectura y estadísticas -->
            <div class="flex flex-col md:flex-row justify-between items-center mb-4">
                <div class="flex items-center space-x-2 text-sm md:text-base">
                    <span id="words-read" class="font-semibold text-blue-600 dark:text-blue-400">0</span>
                    <span class="text-gray-500 dark:text-gray-400">palabras leídas de</span>
                    <span id="total-words" class="font-semibold text-blue-600 dark:text-blue-400">0</span>
                </div>
                <div class="flex items-center space-x-4 mt-2 md:mt-0">
                    <div id="elapsed-time" class="text-sm md:text-base text-gray-500 dark:text-gray-400">Tiempo: 00:00</div>
                    <div id="remaining-time" class="text-sm md:text-base text-gray-500 dark:text-gray-400">Restante: 00:00</div>
                </div>
            </div>

            <!-- Área de visualización del texto de lectura -->
            <div id="reading-display" class="reading-area text-gray-800 dark:text-gray-200 font-inter text-justify transition-all duration-300 overflow-y-auto max-h-[400px] mb-4 p-4 rounded-lg bg-gray-50 dark:bg-gray-800 border border-gray-200 dark:border-gray-600">
                <div id="reading-text-highlight" class="highlight-mode"></div>
                <div id="reading-text-one-word" class="one-word-mode hidden">
                    <span id="word-display" class="word-display"></span>
                </div>
            </div>

            <!-- Panel de Controles -->
            <div class="flex flex-wrap items-center justify-center md:justify-between space-y-4 md:space-y-0 md:space-x-4 mb-4 p-4 rounded-lg bg-gray-100 dark:bg-gray-800 border border-gray-200 dark:border-gray-700">
                <!-- Controles de lectura (Play/Pause, etc) -->
                <div class="flex items-center space-x-2">
                    <button id="prev-btn" class="p-2 text-gray-600 dark:text-gray-300 bg-gray-200 dark:bg-gray-700 rounded-full hover:bg-gray-300 dark:hover:bg-gray-600 transition-colors duration-200" title="Palabra Anterior (←)">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 19l-7-7 7-7" />
                        </svg>
                    </button>
                    <button id="play-pause-btn" class="p-4 text-white bg-blue-500 rounded-full shadow-lg hover:bg-blue-600 transition-colors duration-200" title="Iniciar/Pausar (Espacio)">
                        <svg id="play-icon" xmlns="http://www.w3.org/2000/svg" class="h-8 w-8" viewBox="0 0 20 20" fill="currentColor">
                            <path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zM9.555 7.168A1 1 0 008 8v4a1 1 0 001.555.832l3-2a1 1 0 000-1.664l-3-2z" clip-rule="evenodd" />
                        </svg>
                        <svg id="pause-icon" xmlns="http://www.w3.org/2000/svg" class="h-8 w-8 hidden" viewBox="0 0 20 20" fill="currentColor">
                            <path fill-rule="evenodd" d="M18 10a8 8 0 11-16 0 8 8 0 0116 0zM7 8a1 1 0 012 0v4a1 1 0 11-2 0V8zm5-1a1 1 0 00-1 1v4a1 1 0 102 0V8a1 1 0 00-1-1z" clip-rule="evenodd" />
                        </svg>
                    </button>
                    <button id="next-btn" class="p-2 text-gray-600 dark:text-gray-300 bg-gray-200 dark:bg-gray-700 rounded-full hover:bg-gray-300 dark:hover:bg-gray-600 transition-colors duration-200" title="Siguiente Palabra (→)">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7" />
                        </svg>
                    </button>
                    <button id="stop-btn" class="p-2 text-gray-600 dark:text-gray-300 bg-gray-200 dark:bg-gray-700 rounded-full hover:bg-gray-300 dark:hover:bg-gray-600 transition-colors duration-200" title="Detener Lectura">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 10h6v6h-6z" />
                        </svg>
                    </button>
                </div>

                <!-- Velocidad de lectura (WPM) -->
                <div class="w-full md:w-auto flex items-center justify-center space-x-2 mt-4 md:mt-0">
                    <label for="wpm-slider" class="text-sm font-medium whitespace-nowrap">WPM:</label>
                    <input type="range" id="wpm-slider" min="100" max="1000" value="300" class="w-24 md:w-32 cursor-pointer">
                    <span id="wpm-value" class="font-semibold text-blue-600 dark:text-blue-400 min-w-[3rem]">300</span>
                </div>
            </div>

            <!-- Panel de opciones y ajustes -->
            <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4 mb-4">
                <!-- Selector de Modo de Lectura -->
                <div class="flex items-center space-x-2">
                    <label for="mode-select" class="text-sm font-medium min-w-[5rem]">Modo:</label>
                    <select id="mode-select" class="flex-1 p-2 rounded-lg border border-gray-300 dark:border-gray-600 bg-gray-50 dark:bg-gray-700 text-gray-800 dark:text-gray-200">
                        <option value="highlight">Resaltado</option>
                        <option value="one-word">Una palabra a la vez</option>
                    </select>
                </div>

                <!-- Controles de Resaltado (visibles solo en modo Resaltado) -->
                <div id="highlight-controls" class="flex items-center space-x-2">
                    <label for="highlight-style-select" class="text-sm font-medium min-w-[5rem]">Resaltado:</label>
                    <select id="highlight-style-select" class="flex-1 p-2 rounded-lg border border-gray-300 dark:border-gray-600 bg-gray-50 dark:bg-gray-700 text-gray-800 dark:text-gray-200">
                        <option value="background">Fondo</option>
                        <option value="underline">Subrayado</option>
                        <option value="bold">Negrita (ORP)</option>
                    </select>
                </div>

                <!-- Selector de Tema -->
                <div class="flex items-center space-x-2">
                    <label for="theme-select" class="text-sm font-medium min-w-[5rem]">Tema:</label>
                    <select id="theme-select" class="flex-1 p-2 rounded-lg border border-gray-300 dark:border-gray-600 bg-gray-50 dark:bg-gray-700 text-gray-800 dark:text-gray-200">
                        <option value="light">Claro</option>
                        <option value="dark">Oscuro</option>
                        <option value="sepia">Sepia</option>
                    </select>
                </div>

                <!-- Selector de Fuente -->
                <div class="flex items-center space-x-2">
                    <label for="font-select" class="text-sm font-medium min-w-[5rem]">Fuente:</label>
                    <select id="font-select" class="flex-1 p-2 rounded-lg border border-gray-300 dark:border-gray-600 bg-gray-50 dark:bg-gray-700 text-gray-800 dark:text-gray-200">
                        <option value="inter">Inter (Sans-serif)</option>
                        <option value="playfair">Playfair Display (Serif)</option>
                        <option value="fira-code">Fira Code (Mono)</option>
                    </select>
                </div>

                <!-- Tamaño de la Fuente -->
                <div class="flex items-center space-x-2">
                    <label for="font-size-slider" class="text-sm font-medium whitespace-nowrap min-w-[5rem]">Tamaño:</label>
                    <input type="range" id="font-size-slider" min="12" max="36" value="24" class="flex-1 cursor-pointer">
                    <span id="font-size-value" class="font-semibold text-blue-600 dark:text-blue-400">24px</span>
                </div>
            </div>

            <!-- Panel de entrada de texto y carga de archivos -->
            <div class="mt-6 p-4 rounded-lg border border-gray-300 dark:border-gray-700 bg-gray-100 dark:bg-gray-800">
                <div class="flex flex-col md:flex-row md:justify-between items-center space-y-4 md:space-y-0 md:space-x-4 mb-4">
                    <h3 class="text-lg font-semibold">Cargar Contenido</h3>
                    <div class="flex items-center space-x-2">
                        <button id="paste-btn" class="px-4 py-2 bg-gray-300 dark:bg-gray-600 text-gray-800 dark:text-gray-200 rounded-lg hover:bg-gray-400 dark:hover:bg-gray-500 transition-colors duration-200">Pegar Texto</button>
                        <label for="file-input" class="px-4 py-2 bg-gray-300 dark:bg-gray-600 text-gray-800 dark:text-gray-200 rounded-lg hover:bg-gray-400 dark:hover:bg-gray-500 transition-colors duration-200 cursor-pointer">
                            Subir Archivo
                            <input type="file" id="file-input" class="hidden">
                        </label>
                        <button id="paste-practice-btn" class="px-4 py-2 bg-green-500 text-white rounded-lg hover:bg-green-600 transition-colors duration-200">Modo Práctica</button>
                    </div>
                </div>

                <textarea id="text-input" rows="8" class="w-full p-4 rounded-lg border border-gray-300 dark:border-gray-600 bg-white dark:bg-gray-700 text-gray-900 dark:text-gray-100 resize-y focus:outline-none focus:ring-2 focus:ring-blue-500" placeholder="Pega el texto aquí..."></textarea>
                <p id="status-message" class="mt-2 text-sm text-center text-gray-500 dark:text-gray-400"></p>
                <div id="loading-spinner" class="mt-2 text-center hidden">
                    <div class="w-8 h-8 border-4 border-blue-200 border-t-blue-500 rounded-full animate-spin mx-auto"></div>
                </div>
            </div>

            <!-- Panel de Funcionalidades Avanzadas -->
            <div class="mt-6 p-4 rounded-lg border border-gray-300 dark:border-gray-700 bg-gray-100 dark:bg-gray-800">
                <h3 class="text-lg font-semibold mb-2">Funcionalidades Avanzadas</h3>
                <div class="flex flex-col md:flex-row items-center space-y-4 md:space-y-0 md:space-x-4">
                    <button id="generate-mcq-btn" class="w-full md:w-auto px-4 py-2 bg-blue-500 text-white rounded-lg hover:bg-blue-600 transition-colors duration-200">Generar Cuestionario (Opción Múltiple)</button>
                    <button id="generate-critical-btn" class="w-full md:w-auto px-4 py-2 bg-indigo-500 text-white rounded-lg hover:bg-indigo-600 transition-colors duration-200">Generar Preguntas Críticas</button>
                    <button id="save-session-btn" class="w-full md:w-auto px-4 py-2 bg-purple-500 text-white rounded-lg hover:bg-purple-600 transition-colors duration-200">Guardar Sesión</button>
                    <button id="load-session-btn" class="w-full md:w-auto px-4 py-2 bg-purple-500 text-white rounded-lg hover:bg-purple-600 transition-colors duration-200">Cargar Sesión</button>
                </div>
                <div id="questions-display" class="mt-4 p-4 rounded-lg bg-white dark:bg-gray-700 border border-gray-300 dark:border-gray-600 text-gray-900 dark:text-gray-100 hidden">
                    <h4 id="quiz-title" class="text-md font-semibold mb-2">Cuestionario</h4>
                    <div id="questions-container"></div>
                    <p id="quiz-score" class="text-lg font-bold mt-4 hidden"></p>
                    <button id="submit-quiz-btn" class="mt-4 px-4 py-2 bg-green-500 text-white rounded-lg hover:bg-green-600 transition-colors duration-200 w-full hidden">Autoevaluar</button>
                </div>
            </div>

        </div>
    </div>
    
    <!-- Modal para mensajes y alertas -->
    <div id="message-modal" class="fixed inset-0 bg-gray-600 bg-opacity-50 hidden items-center justify-center p-4 z-50">
        <div class="bg-white dark:bg-gray-700 rounded-lg p-6 shadow-xl w-full max-w-md">
            <h3 id="modal-title" class="text-lg font-bold mb-2 text-gray-900 dark:text-gray-100"></h3>
            <p id="modal-message" class="text-gray-600 dark:text-gray-300 mb-4"></p>
            <div class="flex justify-end">
                <button id="modal-ok-btn" class="px-4 py-2 bg-blue-500 text-white rounded-lg hover:bg-blue-600 transition-colors duration-200">Aceptar</button>
            </div>
        </div>
    </div>
    
    <script>
        // Use a placeholder API key. The Canvas environment will replace this with a valid key.
        const API_KEY = "";
        
        // ** Global Variables **
        let isReading = false;
        let readingInterval;
        let words = [];
        let currentIndex = 0;
        let readingStartTime;
        let timeElapsed = 0;
        let saveInterval;
        let lastKnownPosition = 0; // For session management
        let quizQuestions = []; // To store the generated quiz questions
        
        // ** DOM Elements **
        const readingDisplay = document.getElementById('reading-display');
        const readingTextHighlight = document.getElementById('reading-text-highlight');
        const readingTextOneWord = document.getElementById('reading-text-one-word');
        const wordDisplay = document.getElementById('word-display');
        const textInput = document.getElementById('text-input');
        const wpmSlider = document.getElementById('wpm-slider');
        const wpmValue = document.getElementById('wpm-value');
        const playPauseBtn = document.getElementById('play-pause-btn');
        const stopBtn = document.getElementById('stop-btn');
        const prevBtn = document.getElementById('prev-btn');
        const nextBtn = document.getElementById('next-btn');
        const progressBar = document.getElementById('progress-bar');
        const wordsReadSpan = document.getElementById('words-read');
        const totalWordsSpan = document.getElementById('total-words');
        const elapsedTimeDiv = document.getElementById('elapsed-time');
        const remainingTimeDiv = document.getElementById('remaining-time');
        const modeSelect = document.getElementById('mode-select');
        const highlightControls = document.getElementById('highlight-controls');
        const highlightStyleSelect = document.getElementById('highlight-style-select');
        const themeSelect = document.getElementById('theme-select');
        const fontSelect = document.getElementById('font-select');
        const fontSizeSlider = document.getElementById('font-size-slider');
        const fontSizeValue = document.getElementById('font-size-value');
        const fileInput = document.getElementById('file-input');
        const pasteBtn = document.getElementById('paste-btn');
        const pastePracticeBtn = document.getElementById('paste-practice-btn');
        const statusMessage = document.getElementById('status-message');
        const loadingSpinner = document.getElementById('loading-spinner');
        const generateMcqBtn = document.getElementById('generate-mcq-btn'); // Renamed button
        const generateCriticalBtn = document.getElementById('generate-critical-btn'); // New button
        const questionsDisplay = document.getElementById('questions-display');
        const quizTitle = document.getElementById('quiz-title');
        const questionsContainer = document.getElementById('questions-container');
        const submitQuizBtn = document.getElementById('submit-quiz-btn');
        const quizScore = document.getElementById('quiz-score');
        const saveSessionBtn = document.getElementById('save-session-btn');
        const loadSessionBtn = document.getElementById('load-session-btn');
        const messageModal = document.getElementById('message-modal');
        const modalTitle = document.getElementById('modal-title');
        const modalMessage = document.getElementById('modal-message');
        const modalOkBtn = document.getElementById('modal-ok-btn');

        // ** Helper Functions **

        /**
         * Shows a message modal with a title and message.
         * @param {string} title The title of the modal.
         * @param {string} message The message to display.
         */
        function showMessageModal(title, message) {
            modalTitle.textContent = title;
            modalMessage.textContent = message;
            messageModal.classList.remove('hidden');
            messageModal.classList.add('flex');
        }

        /**
         * Hides the message modal.
         */
        function hideMessageModal() {
            messageModal.classList.add('hidden');
            messageModal.classList.remove('flex');
        }
        
        /**
         * Clears all words from the display and resets the state.
         */
        function clearWords() {
            words = [];
            currentIndex = 0;
            updateUI();
        }

        /**
         * Updates the UI elements based on the current reading state.
         */
        function updateUI() {
            updateProgressBar();
            updateStats();
            updatePlayPauseButton();
            // Show/hide reading modes
            if (modeSelect.value === 'highlight') {
                readingTextHighlight.classList.remove('hidden');
                readingTextOneWord.classList.add('hidden');
            } else {
                readingTextHighlight.classList.add('hidden');
                readingTextOneWord.classList.remove('hidden');
            }
        }
        
        /**
         * Updates the play/pause button icon.
         */
        function updatePlayPauseButton() {
            const playIcon = playPauseBtn.querySelector('#play-icon');
            const pauseIcon = playPauseBtn.querySelector('#pause-icon');
            if (isReading) {
                playIcon.classList.add('hidden');
                pauseIcon.classList.remove('hidden');
            } else {
                playIcon.classList.remove('hidden');
                pauseIcon.classList.add('hidden');
            }
        }
        
        /**
         * Displays the current word based on the reading mode.
         * @param {number} index The index of the current word.
         */
        function displayCurrentWord(index) {
            if (modeSelect.value === 'highlight') {
                highlightCurrentWord(index);
                scrollToCurrentWord(index);
            } else {
                displayOneWord(index);
            }
        }

        /**
         * Displays the current word in "one word at a time" mode.
         * @param {number} index The index of the current word.
         */
        function displayOneWord(index) {
            if (words.length > 0) {
                const word = words[index];
                if (word) {
                    // Check if the word is punctuation
                    const isPunctuation = word.match(/^[.,!?;:]+$/);
                    // Adjust spacing for punctuation
                    wordDisplay.textContent = isPunctuation ? `${word}` : `${word} `;
                }
            } else {
                wordDisplay.textContent = '';
            }
        }

        /**
         * Highlights the current word in "highlight" mode.
         * @param {number} index The index of the current word.
         */
        function highlightCurrentWord(index) {
            // Remove previous highlights
            const highlightedWords = readingTextHighlight.querySelectorAll('.highlighted, .underline, .bold');
            highlightedWords.forEach(word => {
                word.classList.remove('highlighted', 'underline', 'bold');
            });
            
            // Add new highlight
            const currentWord = readingTextHighlight.querySelector(`.word[data-index="${index}"]`);
            if (currentWord) {
                if (highlightStyleSelect.value === 'background') {
                    currentWord.classList.add('highlighted');
                } else if (highlightStyleSelect.value === 'underline') {
                    currentWord.classList.add('underline');
                } else if (highlightStyleSelect.value === 'bold') {
                    // ORP (Optimal Recognition Point)
                    const wordText = currentWord.textContent;
                    const midpoint = Math.floor(wordText.length / 2);
                    const orpWord = document.createElement('span');
                    orpWord.innerHTML = `${wordText.substring(0, midpoint)}<span class="font-bold highlight-text">${wordText.charAt(midpoint)}</span>${wordText.substring(midpoint + 1)}`;
                    currentWord.innerHTML = '';
                    currentWord.appendChild(orpWord);
                }
            }
        }

        /**
         * Scrolls the reading area to keep the current word visible.
         * @param {number} index The index of the current word.
         */
        function scrollToCurrentWord(index) {
            const currentWordElement = readingTextHighlight.querySelector(`.word[data-index="${index}"]`);
            if (currentWordElement) {
                const container = readingDisplay;
                const containerRect = container.getBoundingClientRect();
                const wordRect = currentWordElement.getBoundingClientRect();

                // If the word is not in view, scroll to it
                if (wordRect.top < containerRect.top || wordRect.bottom > containerRect.bottom) {
                    container.scrollTop = currentWordElement.offsetTop - (container.clientHeight / 2) + (wordRect.height / 2);
                }
            }
        }
        
        /**
         * Updates the progress bar based on the current reading position.
         */
        function updateProgressBar() {
            if (words.length > 0) {
                const progress = (currentIndex / words.length) * 100;
                progressBar.style.width = `${progress}%`;
            } else {
                progressBar.style.width = `0%`;
            }
        }
        
        /**
         * Updates the words read and time statistics.
         */
        function updateStats() {
            wordsReadSpan.textContent = currentIndex;
            totalWordsSpan.textContent = words.length;

            if (isReading) {
                timeElapsed = (Date.now() - readingStartTime) / 1000;
            }

            const totalWords = words.length;
            const wpm = parseInt(wpmSlider.value, 10);
            const totalReadingTime = (totalWords / wpm) * 60; // in seconds
            const timeRemaining = totalReadingTime - timeElapsed;

            const formatTime = (seconds) => {
                const minutes = Math.floor(seconds / 60);
                const secs = Math.floor(seconds % 60);
                return `${String(minutes).padStart(2, '0')}:${String(secs).padStart(2, '0')}`;
            };
            
            elapsedTimeDiv.textContent = `Tiempo: ${formatTime(timeElapsed)}`;
            remainingTimeDiv.textContent = `Restante: ${formatTime(timeRemaining > 0 ? timeRemaining : 0)}`;
        }

        /**
         * Updates the display with the new text.
         * @param {string} text The text to display.
         */
        function updateReadingDisplay(text) {
            // Split the text into words and filter out empty strings
            words = text.split(/\s+/).filter(word => word.length > 0);
            currentIndex = 0;
            
            // Rebuild the highlight-mode display
            readingTextHighlight.innerHTML = '';
            words.forEach((word, index) => {
                const wordSpan = document.createElement('span');
                wordSpan.className = 'word inline-block cursor-pointer';
                wordSpan.dataset.index = index;
                wordSpan.textContent = word + ' ';
                readingTextHighlight.appendChild(wordSpan);
            });
            
            updateUI();
        }

        /**
         * Starts the reading process.
         */
        function startReading() {
            if (words.length === 0 || isReading) return;
            isReading = true;
            readingStartTime = Date.now() - (timeElapsed * 1000); // Resume timer
            
            const wpm = parseInt(wpmSlider.value, 10);
            const intervalTime = (60 / wpm) * 1000;

            readingInterval = setInterval(() => {
                if (currentIndex < words.length) {
                    displayCurrentWord(currentIndex);
                    currentIndex++;
                    updateUI();
                } else {
                    stopReading();
                    showMessageModal('Lectura Completa', '¡Has terminado de leer el texto!');
                }
            }, intervalTime);
            updatePlayPauseButton();
        }
        
        /**
         * Pauses the reading process.
         */
        function pauseReading() {
            isReading = false;
            clearInterval(readingInterval);
            readingInterval = null;
            updatePlayPauseButton();
        }
        
        /**
         * Stops the reading process and resets the state.
         */
        function stopReading() {
            pauseReading();
            currentIndex = 0;
            timeElapsed = 0;
            updateUI();
            displayCurrentWord(currentIndex);
            showStatusMessage('Lectura detenida y reiniciada.');
        }

        /**
         * Moves to the previous word.
         */
        function prevWord() {
            if (isReading) pauseReading();
            currentIndex = Math.max(0, currentIndex - 1);
            displayCurrentWord(currentIndex);
            updateUI();
            showStatusMessage(`Retrocediste a la palabra ${currentIndex + 1}.`);
        }

        /**
         * Moves to the next word.
         */
        function nextWord() {
            if (isReading) pauseReading();
            currentIndex = Math.min(words.length - 1, currentIndex + 1);
            displayCurrentWord(currentIndex);
            updateUI();
            showStatusMessage(`Avanzaste a la palabra ${currentIndex + 1}.`);
        }

        /**
         * Displays a status message to the user.
         * @param {string} message The message to show.
         */
        function showStatusMessage(message) {
            statusMessage.textContent = message;
        }
        
        /**
         * Toggles the loading spinner.
         * @param {boolean} show Whether to show or hide the spinner.
         */
        function toggleLoading(show) {
            if (show) {
                loadingSpinner.classList.remove('hidden');
                textInput.disabled = true;
            } else {
                loadingSpinner.classList.add('hidden');
                textInput.disabled = false;
            }
        }
        
        /**
         * Generates multiple-choice questions using the Gemini API.
         */
        async function generateMultipleChoiceQuestions() {
            if (words.length === 0) {
                showMessageModal('Advertencia', 'Por favor, introduce o carga algún texto antes de generar preguntas.');
                return;
            }
            
            questionsDisplay.classList.add('hidden');
            quizQuestions = [];
            questionsContainer.innerHTML = '';
            quizScore.classList.add('hidden');
            submitQuizBtn.classList.add('hidden');
            quizTitle.textContent = 'Cuestionario de Opción Múltiple';

            toggleLoading(true);
            showStatusMessage('Generando preguntas con opciones múltiples...');

            const prompt = `Genera un cuestionario de 5 preguntas de opción múltiple con 4 opciones (A, B, C, D) sobre el siguiente texto. La última opción siempre debe ser "Ninguna de las anteriores" o "Todas las anteriores" dependiendo de la pregunta. Para cada pregunta, incluye la pregunta, las opciones y la respuesta correcta. Asegúrate de que las preguntas y las respuestas estén directamente relacionadas con la información del texto.
            
            TEXTO:
            ${words.join(' ')}
            
            FORMATO JSON REQUERIDO:
            [{
              "question": "Texto de la pregunta",
              "options": ["Opción A", "Opción B", "Opción C", "Opción D"],
              "correctAnswer": "Opción correcta"
            }]`;
            
            let attempts = 0;
            const maxAttempts = 3;

            while (attempts < maxAttempts) {
                try {
                    const payload = {
                        contents: [{
                            role: "user",
                            parts: [{ text: prompt }]
                        }],
                        generationConfig: {
                            responseMimeType: "application/json",
                            responseSchema: {
                                type: "ARRAY",
                                items: {
                                    type: "OBJECT",
                                    properties: {
                                        "question": { "type": "STRING" },
                                        "options": {
                                            "type": "ARRAY",
                                            "items": { "type": "STRING" }
                                        },
                                        "correctAnswer": { "type": "STRING" }
                                    },
                                    "propertyOrdering": ["question", "options", "correctAnswer"]
                                }
                            }
                        }
                    };
                    const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-05-20:generateContent?key=${API_KEY}`;
                    
                    const response = await fetch(apiUrl, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(payload)
                    });
                    
                    if (!response.ok) {
                        throw new Error(`API error: ${response.status} ${response.statusText}`);
                    }
                    
                    const result = await response.json();
                    
                    if (result.candidates && result.candidates.length > 0 &&
                        result.candidates[0].content && result.candidates[0].content.parts &&
                        result.candidates[0].content.parts.length > 0) {
                        const jsonText = result.candidates[0].content.parts[0].text;
                        quizQuestions = JSON.parse(jsonText);
                        renderQuiz();
                        questionsDisplay.classList.remove('hidden');
                        showStatusMessage('Cuestionario generado con éxito. Responde las preguntas a continuación.');
                        break; // Exit the loop on success
                    } else {
                        throw new Error('Respuesta de la API vacía o con formato inesperado.');
                    }
                    
                } catch (error) {
                    console.error('Error al generar preguntas:', error);
                    attempts++;
                    showStatusMessage(`Intento ${attempts}/${maxAttempts}: Fallo al generar preguntas. Reintentando...`);
                    // Implement exponential backoff
                    await new Promise(res => setTimeout(res, 2000 * Math.pow(2, attempts - 1)));
                }
            }

            if (attempts === maxAttempts) {
                showMessageModal('Error', 'No se pudieron generar las preguntas después de varios intentos. Por favor, inténtalo de nuevo más tarde.');
            }
            
            toggleLoading(false);
        }

        /**
         * Generates open-ended critical reading questions using the Gemini API.
         */
        async function generateCriticalQuestions() {
            if (words.length === 0) {
                showMessageModal('Advertencia', 'Por favor, introduce o carga algún texto antes de generar preguntas.');
                return;
            }
            
            questionsDisplay.classList.add('hidden');
            questionsContainer.innerHTML = '';
            quizScore.classList.add('hidden');
            submitQuizBtn.classList.add('hidden');
            quizTitle.textContent = 'Preguntas de Lectura Crítica';

            toggleLoading(true);
            showStatusMessage('Generando preguntas de lectura crítica...');

            const prompt = `Genera un cuestionario de 5 preguntas de lectura crítica y de respuesta abierta sobre el siguiente texto. Estas preguntas deben requerir análisis, síntesis, inferencia y evaluación, no solo el recuerdo de hechos. No incluyas respuestas.
            
            TEXTO:
            ${words.join(' ')}
            
            FORMATO REQUERIDO:
            1. Pregunta 1
            2. Pregunta 2
            ...`;
            
            let attempts = 0;
            const maxAttempts = 3;

            while (attempts < maxAttempts) {
                try {
                    const payload = {
                        contents: [{
                            role: "user",
                            parts: [{ text: prompt }]
                        }],
                    };
                    const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-05-20:generateContent?key=${API_KEY}`;
                    
                    const response = await fetch(apiUrl, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(payload)
                    });
                    
                    if (!response.ok) {
                        throw new Error(`API error: ${response.status} ${response.statusText}`);
                    }
                    
                    const result = await response.json();
                    
                    if (result.candidates && result.candidates.length > 0 &&
                        result.candidates[0].content && result.candidates[0].content.parts &&
                        result.candidates[0].content.parts.length > 0) {
                        const criticalQuestionsText = result.candidates[0].content.parts[0].text;
                        
                        // Render the open-ended questions
                        const questionsHtml = criticalQuestionsText.split('\n').filter(q => q.trim().length > 0).map(q => `<div class="mb-4">${q}</div>`).join('');
                        questionsContainer.innerHTML = questionsHtml;
                        questionsDisplay.classList.remove('hidden');
                        showStatusMessage('Preguntas críticas generadas con éxito. Reflexiona sobre ellas.');
                        break; // Exit the loop on success
                    } else {
                        throw new Error('Respuesta de la API vacía o con formato inesperado.');
                    }
                    
                } catch (error) {
                    console.error('Error al generar preguntas críticas:', error);
                    attempts++;
                    showStatusMessage(`Intento ${attempts}/${maxAttempts}: Fallo al generar preguntas. Reintentando...`);
                    // Implement exponential backoff
                    await new Promise(res => setTimeout(res, 2000 * Math.pow(2, attempts - 1)));
                }
            }

            if (attempts === maxAttempts) {
                showMessageModal('Error', 'No se pudieron generar las preguntas críticas después de varios intentos. Por favor, inténtalo de nuevo más tarde.');
            }
            
            toggleLoading(false);
        }

        /**
         * Renders the multiple-choice quiz on the UI.
         */
        function renderQuiz() {
            questionsContainer.innerHTML = '';
            quizScore.classList.add('hidden');
            if (quizQuestions.length === 0) {
                questionsContainer.textContent = 'No se pudieron generar las preguntas. Por favor, inténtalo de nuevo.';
                submitQuizBtn.classList.add('hidden');
                return;
            }
            
            quizQuestions.forEach((q, index) => {
                const questionDiv = document.createElement('div');
                questionDiv.classList.add('mb-4', 'p-4', 'border', 'rounded-lg', 'border-gray-300', 'dark:border-gray-600');
                
                const questionText = document.createElement('p');
                questionText.classList.add('font-semibold', 'mb-2');
                questionText.textContent = `${index + 1}. ${q.question}`;
                questionDiv.appendChild(questionText);
                
                const optionsList = document.createElement('div');
                optionsList.classList.add('flex', 'flex-col', 'space-y-2');
                
                q.options.forEach((option, optIndex) => {
                    const optionLabel = document.createElement('label');
                    optionLabel.classList.add('flex', 'items-center', 'space-x-2', 'p-3', 'rounded-lg', 'cursor-pointer', 'border', 'border-gray-200', 'dark:border-gray-600', 'hover:bg-gray-100', 'dark:hover:bg-gray-800', 'transition-colors', 'quiz-option');
                    
                    const optionInput = document.createElement('input');
                    optionInput.type = 'radio';
                    optionInput.name = `question-${index}`;
                    optionInput.value = option;
                    optionInput.classList.add('form-radio', 'h-4', 'w-4', 'text-blue-600', 'border-gray-300', 'dark:border-gray-500', 'dark:bg-gray-700', 'focus:ring-blue-500');
                    
                    const optionText = document.createElement('span');
                    optionText.textContent = option;
                    
                    optionLabel.appendChild(optionInput);
                    optionLabel.appendChild(optionText);
                    optionsList.appendChild(optionLabel);
                });
                
                questionDiv.appendChild(optionsList);
                questionsContainer.appendChild(questionDiv);
            });
            
            submitQuizBtn.classList.remove('hidden');
        }

        /**
         * Evaluates the quiz and displays the score.
         */
        function submitQuiz() {
            let score = 0;
            const totalQuestions = quizQuestions.length;
            
            quizQuestions.forEach((q, index) => {
                const questionDiv = questionsContainer.children[index];
                const selectedOption = questionDiv.querySelector(`input[name="question-${index}"]:checked`);
                
                // Remove previous feedback classes
                const allLabels = questionDiv.querySelectorAll('.quiz-option');
                allLabels.forEach(label => label.classList.remove('correct', 'incorrect'));
                
                // Find and highlight the correct answer
                const correctOptionLabel = Array.from(allLabels).find(label => {
                    const input = label.querySelector('input');
                    return input.value === q.correctAnswer;
                });
                if (correctOptionLabel) {
                    correctOptionLabel.classList.add('correct');
                }

                if (selectedOption) {
                    // Check if the selected answer is correct
                    if (selectedOption.value === q.correctAnswer) {
                        score++;
                    } else {
                        // Highlight the incorrect answer
                        const selectedLabel = selectedOption.closest('label');
                        if (selectedLabel) {
                            selectedLabel.classList.add('incorrect');
                        }
                    }
                }
                
                // Disable all options after submission
                const allInputs = questionDiv.querySelectorAll('input[type="radio"]');
                allInputs.forEach(input => input.disabled = true);
            });
            
            quizScore.textContent = `Tu puntuación es: ${score} de ${totalQuestions}`;
            quizScore.classList.remove('hidden');
            submitQuizBtn.classList.add('hidden');
            showMessageModal('Autoevaluación Completa', `Has respondido ${score} de ${totalQuestions} preguntas correctamente.`);
        }

        // ** Event Listeners **

        // Control buttons
        playPauseBtn.addEventListener('click', () => {
            if (isReading) {
                pauseReading();
            } else {
                startReading();
            }
        });
        stopBtn.addEventListener('click', stopReading);
        prevBtn.addEventListener('click', prevWord);
        nextBtn.addEventListener('click', nextWord);
        generateMcqBtn.addEventListener('click', generateMultipleChoiceQuestions);
        generateCriticalBtn.addEventListener('click', generateCriticalQuestions);
        submitQuizBtn.addEventListener('click', submitQuiz); // New event listener for the quiz
        saveSessionBtn.addEventListener('click', saveSession);
        loadSessionBtn.addEventListener('click', loadSession);
        modalOkBtn.addEventListener('click', hideMessageModal);

        // Input and control changes
        wpmSlider.addEventListener('input', () => {
            wpmValue.textContent = wpmSlider.value;
            // Recalculate remaining time immediately
            updateStats();
            // Restart the interval if reading
            if (isReading) {
                pauseReading();
                startReading();
            }
        });

        fontSizeSlider.addEventListener('input', () => {
            fontSizeValue.textContent = `${fontSizeSlider.value}px`;
            readingDisplay.style.fontSize = `${fontSizeSlider.value}px`;
        });
        
        textInput.addEventListener('input', () => {
            // Stop reading and update on text change
            stopReading();
            if (textInput.value.trim().length > 0) {
                updateReadingDisplay(textInput.value);
            } else {
                clearWords();
            }
        });

        // Function to handle reading settings updates
        function updateReadingSettings() {
            // Font update
            readingDisplay.style.fontFamily = `"${fontSelect.value}"`;
            
            // Theme update
            document.body.className = `${themeSelect.value}-mode bg-gray-100 text-gray-800 font-inter`;
            
            // Mode and highlight style update
            if (modeSelect.value === 'highlight') {
                readingTextHighlight.classList.remove('hidden');
                readingTextOneWord.classList.add('hidden');
                highlightControls.style.display = 'flex';
                // Remove all highlight classes before re-adding
                readingTextHighlight.className = 'highlight-mode';
            } else {
                readingTextHighlight.classList.add('hidden');
                readingTextOneWord.classList.remove('hidden');
                highlightControls.style.display = 'none';
            }
        }

        modeSelect.addEventListener('change', updateReadingSettings);
        highlightStyleSelect.addEventListener('change', () => {
            // Re-render the display to apply the new style
            if (textInput.value.trim().length > 0) {
                updateReadingDisplay(textInput.value);
            }
        });
        themeSelect.addEventListener('change', updateReadingSettings);
        fontSelect.addEventListener('change', updateReadingSettings);
        
        // File input handler
        fileInput.addEventListener('change', (event) => {
            const file = event.target.files[0];
            if (!file) {
                return;
            }
            
            const reader = new FileReader();
            reader.onloadstart = () => {
                toggleLoading(true);
                showStatusMessage('Cargando archivo...');
            };

            reader.onload = async (e) => {
                const fileType = file.type;
                let textContent = '';
                
                try {
                    if (fileType === 'application/pdf') {
                        showStatusMessage('Extrayendo texto del PDF...');
                        // Use pdf.js to extract text from PDF
                        const typedarray = new Uint8Array(e.target.result);
                        const pdf = await pdfjsLib.getDocument({ data: typedarray }).promise;
                        for (let i = 1; i <= pdf.numPages; i++) {
                            const page = await pdf.getPage(i);
                            const textContentResult = await page.getTextContent();
                            textContent += textContentResult.items.map(item => item.str).join(' ');
                        }
                    } else if (fileType.startsWith('image/')) {
                        showStatusMessage('Reconociendo texto de la imagen (OCR)...');
                        // Use Tesseract.js to perform OCR on image
                        const { data: { text } } = await Tesseract.recognize(
                            file,
                            'spa', // language code for Spanish
                            {
                                logger: m => {
                                    if (m.status === 'recognizing text') {
                                        showStatusMessage(`Reconociendo texto: ${Math.round(m.progress * 100)}%`);
                                    }
                                }
                            }
                        );
                        textContent = text;
                    } else if (fileType === 'text/plain') {
                        textContent = e.target.result;
                    } else {
                        throw new Error('Tipo de archivo no soportado. Por favor, sube un archivo de texto (.txt), PDF, o una imagen.');
                    }

                    if (textContent.trim().length > 0) {
                        textInput.value = textContent;
                        updateReadingDisplay(textContent);
                        showStatusMessage('Archivo cargado con éxito.');
                    } else {
                        throw new Error('El archivo no contiene texto o no se pudo extraer.');
                    }

                } catch (error) {
                    console.error('Error al cargar archivo:', error);
                    showMessageModal('Error de Archivo', `Error al procesar el archivo. ${error.message}`);
                    textInput.value = '';
                    clearWords();
                } finally {
                    toggleLoading(false);
                }
            };
            
            // Read file based on type
            if (file.type === 'application/pdf') {
                reader.readAsArrayBuffer(file);
            } else {
                reader.readAsDataURL(file);
            }
        });
        
        // Paste button handler
        pasteBtn.addEventListener('click', async () => {
            try {
                // Check for clipboard API support
                if (!navigator.clipboard || !navigator.clipboard.readText) {
                    throw new Error('La API del Portapapeles no está disponible en este navegador o entorno.');
                }
                const text = await navigator.clipboard.readText();
                if (text.trim().length > 0) {
                    textInput.value = text;
                    updateReadingDisplay(text);
                    showStatusMessage('Texto pegado del portapapeles.');
                } else {
                    showMessageModal('Advertencia', 'El portapapeles está vacío.');
                }
            } catch (err) {
                console.error('Error al pegar del portapapeles:', err);
                showMessageModal('Error', `No se pudo acceder al portapapeles. Por favor, pégalo manualmente en el cuadro de texto. Detalle: ${err.message}`);
            }
        });

        // Practice mode button handler
        pastePracticeBtn.addEventListener('click', () => {
            const practiceText = `La lectura rápida, también conocida como speed reading, es un conjunto de técnicas y métodos cuyo objetivo principal es aumentar la velocidad de lectura sin disminuir significativamente la comprensión. Históricamente, se ha promovido como una habilidad valiosa para profesionales y estudiantes que necesitan procesar grandes volúmenes de información en poco tiempo. Algunas de las estrategias clave incluyen la eliminación de la subvocalización (la tendencia a "pronunciar" las palabras en silencio), la reducción de las fijaciones oculares (enfocarse en grupos de palabras en lugar de una por una) y el uso de un puntero o guía visual para dirigir el ojo a través del texto.

Aunque hay cierto debate sobre la eficacia real de estas técnicas para textos complejos que requieren una comprensión profunda, la lectura rápida puede ser una herramienta útil para escanear y revisar material. Su práctica regular no solo puede acelerar la velocidad de decodificación, sino también entrenar al cerebro para procesar información de manera más eficiente. Con el auge de las tecnologías digitales y el inmenso flujo de datos, la capacidad de leer de manera más rápida y selectiva se ha vuelto cada vez más relevante. Sin embargo, los expertos sugieren que la clave del éxito no radica en la velocidad por sí sola, sino en la capacidad de adaptar la técnica de lectura al tipo de material y al propósito de la misma, combinando la velocidad con la comprensión y la retención.`;
            textInput.value = practiceText;
            updateReadingDisplay(practiceText);
            showStatusMessage('Modo práctica activado. Un texto de muestra ha sido cargado.');
        });
        
        /**
         * Saves the current reading session to session storage.
         */
        function saveSession() {
            if (words.length === 0) {
                showMessageModal('Advertencia', 'No hay nada que guardar. Por favor, introduce texto primero.');
                return;
            }
            const sessionData = {
                text: textInput.value,
                currentIndex: currentIndex,
                wpm: wpmSlider.value,
                mode: modeSelect.value,
                highlightStyle: highlightStyleSelect.value,
                theme: themeSelect.value,
                font: fontSelect.value,
                fontSize: fontSizeSlider.value,
                timeElapsed: timeElapsed,
            };
            try {
                sessionStorage.setItem('speedReaderSession', JSON.stringify(sessionData));
                showMessageModal('Sesión Guardada', 'Tu progreso de lectura ha sido guardado en el navegador.');
            } catch (error) {
                console.error('Error al guardar la sesión:', error);
                showMessageModal('Error', 'No se pudo guardar la sesión. Es posible que el navegador no lo permita.');
            }
        }
        
        /**
         * Loads a previously saved reading session from session storage.
         */
        function loadSession() {
            try {
                const sessionData = JSON.parse(sessionStorage.getItem('speedReaderSession'));
                if (sessionData) {
                    // Restore text and settings
                    textInput.value = sessionData.text;
                    wpmSlider.value = sessionData.wpm;
                    modeSelect.value = sessionData.mode;
                    highlightStyleSelect.value = sessionData.highlightStyle;
                    themeSelect.value = sessionData.theme;
                    fontSelect.value = sessionData.font;
                    fontSizeSlider.value = sessionData.fontSize;
                    timeElapsed = sessionData.timeElapsed;
                    currentIndex = sessionData.currentIndex;
                    
                    // Trigger UI updates
                    updateReadingDisplay(sessionData.text);
                    updateReadingSettings();
                    updateUI();
                    displayCurrentWord(currentIndex);
                    
                    showMessageModal('Sesión Cargada', 'Tu sesión de lectura anterior ha sido restaurada.');
                } else {
                    showMessageModal('No hay sesión', 'No se encontró una sesión de lectura guardada.');
                }
            } catch (error) {
                console.error('Error al cargar la sesión:', error);
                showMessageModal('Error', 'No se pudo cargar la sesión. Los datos podrían estar corruptos.');
            }
        }

        // Click event on reading text to change position
        readingTextHighlight.addEventListener('click', (event) => {
            const target = event.target;
            // Check if the clicked element is a word span
            if (target.classList.contains('word') && modeSelect.value === 'highlight') {
                const newIndex = parseInt(target.dataset.index, 10);
                if (!isNaN(newIndex)) {
                    currentIndex = newIndex;
                    pauseReading();
                    displayCurrentWord(currentIndex);
                    showStatusMessage(`Posición de inicio cambiada a la palabra ${newIndex + 1}.`);
                }
            }
        });

        // Keyboard controls
        document.addEventListener('keydown', (event) => {
            if (event.code === 'Space') {
                event.preventDefault();
                isReading ? pauseReading() : startReading();
            }
            if (event.code === 'ArrowLeft') {
                event.preventDefault();
                prevWord();
            }
            if (event.code === 'ArrowRight') {
                event.preventDefault();
                nextWord();
            }
        });
        
        // Initial setup to show/hide controls based on default mode
        const isHighlightModeInitially = modeSelect.value === 'highlight';
        highlightControls.style.display = isHighlightModeInitially ? 'flex' : 'none';

        // Initial setup to update reading display if text is already present
        if (textInput.value.trim().length > 0) {
            updateReadingDisplay(textInput.value);
        }
    </script>
</body>
</html>
